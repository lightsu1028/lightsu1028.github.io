[{"content":"本篇文章主要是介绍Spring在生成BeanDefinition的过程中，涉及到的扩展接口BeanFactoryPostProcessor以及子接口BeanDefinitionRegistryPostProcessor的介绍、作用以及Spring内部的一些既有实现。\nBeanFactoryPostProcessor是什么？ 用于对beanFactory进行回调处理，允许用户对应用上下文中的bean定义进行自定义修改，主要通过底层容器beanFactory对bean属性值进行适配处理。 比如通过用户自定义的外部属性配置文件（主要是.properties）在程序运行时动态的更改Spring容器中bean的属性值，从而提供了一种在配置文件之外修改 bean 属性的机制。 PropertyResourceConfigurer抽象类就是一个开箱即用的既有实现。\n上述官方文档中的说明指明了2件事：\nBeanFactoryPostProcessor提供了一种对beanFactory进行回调处理的机制，作为SPI扩展点 通过对beanFactory回调，可以在程序运行时动态处理bean属性值，比如替换被@Value修饰的属性占位符 看下BeanFactoryPostProcessor的接口定义： 1 2 3 4 5 6 7 org.springframework.beans.factory.config.BeanFactoryPostProcessor public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } BeanFactoryPostProcessor接口中只有一个定义的方法，入参是ConfigurableListableBeanFactory，通过beanFactory就可以获取指定的beanDefinition，进而修改beanDefinition。BeanFactoryPostProcessor作用的时机应该是所有的bean定义已经被加载了但是还没实例化，此时可以修改属性。注意：ConfigurableListableBeanFactory只具备查询beanDefinition的能力，并不能对beanDefinition增删即进行注册。\n如何使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component public class User { private String name = \u0026#34;test001\u0026#34;; public Integer salary; // 省略get set方法 ... } @Component public class SalaryBeanFactoryPostProcessor implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { // 获取user的bean定义 BeanDefinition user = beanFactory.getBeanDefinition(\u0026#34;user\u0026#34;); // 获取user bean定义的属性 MutablePropertyValues propertyValues = user.getPropertyValues(); // 对user的属性salary赋值 propertyValues.add(\u0026#34;salary\u0026#34;, 1000); } } public static void main(String[] args) { // 创建一个Spring容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); User user = (User) applicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user); } 程序中定义了User用户对象并通过@Component声明为bean，用户对象有个属性salary，现在要对所有用户bean的salary属性统一赋默认值1000。我们就可以使用自定义的SalaryBeanFactoryPostProcessor组件在postProcessBeanFactory方法中进行属性的统一赋值。\nBeanDefinitionRegistryPostProcessor是什么？ BeanFactoryPostProcessor的SPI扩展，在BeanFactoryPostProcessor开始作用前允许注册beanDefinition。Spring内部提供了相应实现org.springframework.context.annotation.ConfigurationClassPostProcessor。\nBeanDefinitionRegistryPostProcessor看名字就知道应该是跟bean定义的注册相关的后置处理器。由于BeanFactoryPostProcessor只支持bean定义属性的修改而不支持bean定义的注册，所以相关实现就由BeanDefinitionRegistryPostProcessor接口定义，算是对BeanFactoryPostProcessor的补充。惯例看下相关接口的定义：\n1 2 3 4 5 6 org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; } postProcessBeanDefinitionRegistry方法的入参为BeanDefinitionRegistry，BeanDefinitionRegistry可以对bean定义进行注册、删除、查询。跟BeanFactoryPostProcessor的作用时机一样也是在所有bean定义被加载还未被实例化之前，而且会比BeanFactoryPostProcessor#postProcessBeanFactory优先作用。\n如何使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class User { private String name = \u0026#34;test001\u0026#34;; public Integer salary; } @Component public class AddUserBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { } @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { // 创建User bean定义 RootBeanDefinition userBeanDefinition = new RootBeanDefinition(User.class); // 设置属性 MutablePropertyValues propertyValues = userBeanDefinition.getPropertyValues(); propertyValues.addPropertyValue(\u0026#34;name\u0026#34;, \u0026#34;test002\u0026#34;); propertyValues.addPropertyValue(\u0026#34;salary\u0026#34;, 1000); // 注册bean定义 registry.registerBeanDefinition(\u0026#34;user\u0026#34;, userBeanDefinition); } } public static void main(String[] args) { // 创建一个Spring容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); User user = (User) applicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user); /*UserService userService = (UserService) applicationContext.getBean(\u0026#34;user\u0026#34;); userService.test();*/ } 自定义AddUserBeanDefinitionRegistryPostProcessor实现了BeanDefinitionRegistryPostProcessor接口，在postProcessBeanDefinitionRegistry方法中手动编程式的创建了User类的bean定义并进行了属性的赋值，最后调用BeanDefinitionRegistry注册到容器中去。最后使用applicationContext通过beanName可以获取到User类型的bean。\nSpring内部实现 BeanFactoryPostProcessor实现 PropertyResourceConfigurer：主要进行属性值的替换，包括了子类PropertyOverrideConfigurer在外部属性文件.properties中通过beanName.property=value这种kv的形式定义需要覆盖的bean属性达到替换bean属性值的目的；PlaceholderConfigurerSupport用于从外部配置中读取属性文件中的占位符定义（${\u0026hellip;}），并在容器启动时将其替换为实际的值。 ConfigurationClassPostProcessor: // TODO EventListenerMethodProcessor：用于处理Spring应用程序上下文中的事件监听方法。主要作用是扫描Spring容器中的Bean，查找其中标注了事件监听注解（@EventListener）的方法，并将其注册为事件监听器。当事件发生时，Spring将会调用这些注册的事件监听方法。 CustomScopeConfigurer：于配置自定义的作用域（Scope）。 AspectJWeavingEnabler：用于启用AspectJ编织（weaving）功能。 CustomAutowireConfigurer ：用于配置自定义的自动装配规则 CustomEditorConfigurer ：用于配置自定义的属性编辑器（PropertyEditor）。属性编辑器用于将字符串值转换为特定类型的对象，或将对象转换为字符串值。配置了自定义属性编辑器，Spring就会在容器启动时注册自定义的属性编辑器，从而影响属性值的转换行为。这样，在进行属性注入时，Spring 将会使用注册的自定义属性编辑器来进行类型转换。 BeanDefinitionRegistryPostProcessor实现 BeanDefinitionRegistryPostProcessor在Spring内部的实现只有ConfigurationClassPostProcessor，同时ConfigurationClassPostProcessor还继承了BeanFactoryPostProcessor接口。\nConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor，主要进行解析配置类，通过配置类进一步解析得到所有的bean定义，扫描含有@ComponentScan、 @Import、@ImportResource、@Bean、@PropertySource等注解的bean定义。可以说ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry非常重要，bean定义的扫描解析的入口就是在这了。\nSpring在何时调用BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor？ 上面介绍了这两个接口是干什么的以及内部的一些既有实现。那么还有最后一个问题，就是Spring是在何时使用这些SPI接口的呢？或者说在上下文容器的生命周期的哪个环节起作用的呢？并且这两个接口都是跟beanDefinition是相关的，那么他们的先后作用顺序又是怎样的呢？\n由于这两个接口的实现比较多，本篇文章选取ConfigurationClassPostProcessor这个共有的实现类作为源码分析对象，因为ConfigurationClassPostProcessor也是后续bean定义扫描解析的入口。\n上面是ConfigurationClassPostProcessor从创建到使用的整个流程。大致可以分为三个阶段，青色部分为容器上下文为创建ConfigurationClassPostProcessor的准备阶段，此阶段主要是预先注册ConfigurationClassPostProcessor的bean定义以及准备后续会使用到的BeanFactory；蓝色部分为一阶段注册的BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor的实例化以及编排调用；三阶段就是具体的postProcessBeanDefinitionRegistry的执行，此处选取了ConfigurationClassPostProcessor，主要就是进行各种BeanDefinition的解析了。\nBeanFactoryPostProcessor创建准备 在Spring中，万物都是Bean，用户创建的自定义类是bean，Spring基础组件也是bean。既然是bean，那么都会经过IOC被创建后使用，也就会需要进行相应的BeanDefinition注册。\n对于像BeanFactoryPostProcessor这种基础组件，Spring会在容器上下文初始化时预先编程式注册对应的bean定义。 BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor的两个方法中需要用到BeanFactory和BeanDefinitionRegistry，所以在初始化时也就需要创建相应的组件供其后续使用。 上述两个步骤是在哪里实现的呢？看一下容器上下文AnnotationConfigApplicationContext的构造函数源码便可知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 org.springframework.context.support.GenericApplicationContext // 父类GenericApplicationContext无参构造函数 public GenericApplicationContext() { this.beanFactory = new DefaultListableBeanFactory(); } org.springframework.context.annotation.AnnotationConfigApplicationContext // 无参构造函数 public AnnotationConfigApplicationContext() { // 额外会创建StandardEnvironment this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); this.scanner = new ClassPathBeanDefinitionScanner(this); } // 使用自定义的BeanFactory初始化AnnotationConfigApplicationContext public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) { // 调用父类GenericApplicationContext的有参构造函数初始化beanFactory super(beanFactory); this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this); } // 使用自定义组件类即组件配置类（含有@Configuration注解的类、含有@ComponentScan的类）初始化 public AnnotationConfigApplicationContext(Class\u0026lt;?\u0026gt;... componentClasses) { // 调用无参构造函数 // 构造DefaultListableBeanFactory、AnnotatedBeanDefinitionReader、ClassPathBeanDefinitionScanner this(); // 注册组件类即注册配置类 register(componentClasses); // 刷新容器 refresh(); } // 使用类路径（路径下用户自定义bean）初始化 public AnnotationConfigApplicationContext(String... basePackages) { this(); scan(basePackages); refresh(); } 可以看到AnnotationConfigApplicationContext的构造函数有很多，有参数的可以使用自定义BeanFactory、自定义的配置类、直接指定要扫描的类路径。但是这些构造函数中都会直接或间接的创建AnnotatedBeanDefinitionReader、ClassPathBeanDefinitionScanner，还有一个隐性的操作就是重载AnnotationConfigApplicationContext无参构造函数初始化的同时也会调用父类GenericApplicationContext的无参构造函数创建一个DefaultListableBeanFactory的beanFactory。这个DefaultListableBeanFactory是干什么用的？\nDefaultListableBeanFactory的顶层接口有BeanFactory和BeanDefinitionRegistry，这就是后续BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor接口方法中需要用到的组件，在GenericApplicationContext的无参构造函数中进行了初始化创建。 继续深入分析AnnotatedBeanDefinitionReader的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // 使用AnnotationConfigApplicationContext作为registry传入 public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) { this(registry, getOrCreateEnvironment(registry)); } public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) { this.registry = registry; // 用来解析@Conditional注解的 this.conditionEvaluator = new ConditionEvaluator(registry, environment, null); // 使用registry注册所有注解相关的后置处理器bean定义 AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } org.springframework.context.annotation.AnnotationConfigUtils public static Set\u0026lt;BeanDefinitionHolder\u0026gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, @Nullable Object source) { DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) { // 设置beanFactory的OrderComparator为AnnotationAwareOrderComparator // 它是一个Comparator，是一个比较器，可以用来进行排序，比如new ArrayList\u0026lt;\u0026gt;().sort(Comparator); if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) { beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); } // 用来判断某个Bean能不能用来进行依赖注入 if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) { beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); } } Set\u0026lt;BeanDefinitionHolder\u0026gt; beanDefs = new LinkedHashSet\u0026lt;\u0026gt;(8); // 注册ConfigurationClassPostProcessor类型的BeanDefinition if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册AutowiredAnnotationBeanPostProcessor类型的BeanDefinition if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册CommonAnnotationBeanPostProcessor类型的BeanDefinition if (jsr250Present \u0026amp;\u0026amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册PersistenceAnnotationBeanPostProcessor类型的BeanDefinition if (jpaPresent \u0026amp;\u0026amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(); try { def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); } catch (ClassNotFoundException ex) { throw new IllegalStateException( \u0026#34;Cannot load optional framework class: \u0026#34; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); } def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册EventListenerMethodProcessor类型的BeanDefinition，用来处理@EventListener注解的 if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); } // 注册DefaultEventListenerFactory类型的BeanDefinition，用来处理@EventListener注解的 if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME)); } return beanDefs; } 一路分析AnnotatedBeanDefinitionReader的源码发现，在AnnotatedBeanDefinitionReader的创建过程中，最终会调用org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors注册各种的后置处理器bean定义，这些后置处理器都是作为Spring的基础组件提供后续服务的。其中就包含BeanFactoryPostProcessor相关的ConfigurationClassPostProcessor和EventListenerMethodProcessor两个实现。\n第25-27行中，beanFactory手动注册了Comparator实例AnnotationAwareOrderComparator用于后续编排BeanFactoryPostProcessor实现时进行排序，AnnotationAwareOrderComparator继承了OrderComparator，相关用法和源码解析在Spring源码BeanDefinition解析之ClassPathBeanDefinitionScanner一文中OrderComparator章节已经介绍过了。\nBeanFactoryPostProcessor调用编排 BeanDefinitionRegistryPostProcessor接口继承了BeanFactoryPostProcessor接口，本质上也是BeanFactoryPostProcessor。那么如果程序中同时出现这两种接口的实现，这2种类型的接口实现优先级顺序如何定义呢？每一种类型的接口实现中如果有的实现了PriorityOrdered接口，有的实现了Ordered接口那么优先级又如何定义呢？同时Spring中这2种类型的接口实现有的是通过编程式用户手动添加注册、有的是通过@Component注解声明式定义的那么优先级顺序又如何定义呢？本质上来说针对BeanFactoryPostProcessor及其子接口的实现Spring需要从添加方式、接口类型、接口优先级这三个维度进行执行顺序的编排！这里先直接给出结论，再进行源码解析。\n执行顺序的源码如上图所示，源码位于org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors方法中。整体执行流程在实例化bean之前。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List\u0026lt;BeanFactoryPostProcessor\u0026gt; beanFactoryPostProcessors) { // BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set\u0026lt;String\u0026gt; processedBeans = new HashSet\u0026lt;\u0026gt;(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; List\u0026lt;BeanFactoryPostProcessor\u0026gt; regularPostProcessors = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;BeanDefinitionRegistryPostProcessor\u0026gt; registryProcessors = new ArrayList\u0026lt;\u0026gt;(); // beanFactoryPostProcessors集合一般情况下都是空的，除非我们手动调用容器的addBeanFactoryPostProcessor方法添加了 // beanFactoryPostProcessors中可能包含了：普通BeanFactoryPostProcessor对象和BeanDefinitionRegistryPostProcessor对象 // 对于BeanDefinitionRegistryPostProcessor对象，会执行自己的postProcessBeanDefinitionRegistry()方法 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List\u0026lt;BeanDefinitionRegistryPostProcessor\u0026gt; currentRegistryProcessors = new ArrayList\u0026lt;\u0026gt;(); // 执行扫描出来的BeanDefinitionRegistryPostProcessor // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } // 升序排序 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { // processedBeans表示该beanFactoryPostProcessor的postProcessBeanDefinitionRegistry()方法已经执行过了，不再重复执行 if (!processedBeans.contains(ppName) \u0026amp;\u0026amp; beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. // 执行哪些没有实现了PriorityOrdered或Ordered接口的普通BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法 // 在这个过程中可能会向BeanFactory中注册另外的BeanDefinitionRegistryPostProcessor，所以需要while，直到确定所有的BeanDefinitionRegistryPostProcessor都执行完了 // 在这个过程中注册的BeanDefinitionRegistryPostProcessor，所实现的PriorityOrdered或Ordered接口可能会不按顺序执行 // 比如 A注册了B和C,B又注册了D和E,那么B和C会按顺序执行，D和E也会按顺序执行，但是B、C、D、E整体不能保证是顺序执行 boolean reiterate = true; while (reiterate) { reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); } // Now, invoke the postProcessBeanFactory callback of all processors handled so far. // 执行完BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法后， // 再执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法 invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); // 执行手动添加的普通BeanFactoryPostProcessor的postProcessBeanFactory()方法 invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); } else { // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); } // 执行扫描出来的普通BeanFactoryPostProcessor // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List\u0026lt;BeanFactoryPostProcessor\u0026gt; priorityOrderedPostProcessors = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; orderedPostProcessorNames = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; nonOrderedPostProcessorNames = new ArrayList\u0026lt;\u0026gt;(); // 先进行分类 for (String ppName : postProcessorNames) { if (processedBeans.contains(ppName)) { // skip - already processed in first phase above } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List\u0026lt;BeanFactoryPostProcessor\u0026gt; orderedPostProcessors = new ArrayList\u0026lt;\u0026gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) { orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List\u0026lt;BeanFactoryPostProcessor\u0026gt; nonOrderedPostProcessors = new ArrayList\u0026lt;\u0026gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) { nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache(); } 第7-25行：优先执行编程式手动添加的BeanDefinitionRegistryPostProcessor实现，同时筛选出手动添加的BeanFactoryPostProcessor实现供后续执行。 第31-48行：执行扫描出的BeanDefinitionRegistryPostProcessor类型的实现了PriorityOrdered接口的实现的postProcessBeanDefinitionRegistry方法。这部分功能通过BeanFactory查找、实例化实现。 第51-62行：执行扫描出的BeanDefinitionRegistryPostProcessor类型的实现了Ordered接口的实现的postProcessBeanDefinitionRegistry方法。 第69-83行：执行未继承任何优先级顺序接口的普通BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。如果在执行postProcessBeanDefinitionRegistry方法时又注册了BeanDefinitionRegistryPostProcessor的Bean定义，那么会迭代继续获取BeanDefinitionRegistryPostProcessor实现并执行postProcessBeanDefinitionRegistry方法，直到最后容器中找不到BeanDefinitionRegistryPostProcessor或者找到的BeanDefinitionRegistryPostProcessor已经都被执行过了才停止。 第89行：由于BeanDefinitionRegistryPostProcessor类型的实现也继承了BeanFactoryPostProcessor接口，所以前面手动显示注册的BeanDefinitionRegistryPostProcessor实现和声明式注册的BeanDefinitionRegistryPostProcessor实现最后会被调用执行其postProcessBeanFactory方法。至此所有手动或自动添加的BeanDefinitionRegistryPostProcessor的实现的所有方法都已经被实现。 第92-97行：执行手动添加的BeanFactoryPostProcessor实现的postProcessBeanFactory方法。 第104-126行：扫描BeanFactoryPostProcessor的实现按PriorityOrdered、Ordered、未继承优先级顺序接口分类。 第129-149行：一次执行分类的BeanFactoryPostProcessor实现。 整个invokeBeanFactoryPostProcessors方法的逻辑还是比较简单清晰的，首先Spring根据接口类型进行优先级分类，先执行BeanDefinitionRegistryPostProcessor相关实现的所有方法，再实现BeanFactoryPostProcessor实现的方法；接着对于每一类接口，都是优先执行手动编程式添加的组件，然后再执行声明式添加的组件；对于声明式方法添加的组件，再根据优先级接口顺序决定执行先后顺序。\n","date":"2024-04-08T00:00:00Z","image":"https://example.com/p/spring-beanfactorypostprocessor/bfbakground_hu96d90dc5f8b15514dce117f010950681_232349_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/spring-beanfactorypostprocessor/","title":"Spring BeanFactoryPostProcessor"},{"content":"本篇文章主要是介绍Spring在生成BeanDefinition的过程中，涉及到的核心组件ClassPathBeanDefinitionScanner的主流程源码解析。ClassPathBeanDefinitionScanner涉及到的相关底层API使用我在另一篇博文中已经介绍过了Spring源码BeanDefinition解析之ClassPathBeanDefinitionScanner\n扫描解析入口方法 Spring上下文容器在扫描时会调用org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan进行解析指定包路径下面的候选 定义，具体Spring是在哪调用该方法进入扫描解析流程的后续再详细分析，本篇专注解析逻辑本身。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public int scan(String... basePackages) { // 获取已经扫描的bean定义个数 int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); // 开始扫描解析 doScan(basePackages); // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) { AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } // 计算本次实际扫描解析到的bean定义个数 return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart); } scan方法中并没有核心的解析逻辑，主要做了两件事，第一件事调用doScan(basePackages)方法解析用户包路径下的自定义的BeanDefinition。第二件事就是向上下文容器中直接注册注解配置相关的处理器BeanDefinition，后续就可以直接使用这些infra组件辅助完成容器的后续初始化工作。\n注册基础组件 Spring默认会进行基础组件BeanDefinition的手动注册，这些基础组件的BeanDefinition后续会直接实例化辅助Spring容器初始化，具体的方法逻辑如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) public static Set\u0026lt;BeanDefinitionHolder\u0026gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, @Nullable Object source) { DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) { // 设置beanFactory的OrderComparator为AnnotationAwareOrderComparator // 它是一个Comparator，是一个比较器，可以用来进行排序，比如new ArrayList\u0026lt;\u0026gt;().sort(Comparator); if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) { beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); } // 用来判断某个Bean能不能用来进行依赖注入 if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) { beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); } } Set\u0026lt;BeanDefinitionHolder\u0026gt; beanDefs = new LinkedHashSet\u0026lt;\u0026gt;(8); // 注册ConfigurationClassPostProcessor类型的BeanDefinition if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册AutowiredAnnotationBeanPostProcessor类型的BeanDefinition if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册CommonAnnotationBeanPostProcessor类型的BeanDefinition // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present \u0026amp;\u0026amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册PersistenceAnnotationBeanPostProcessor类型的BeanDefinition // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent \u0026amp;\u0026amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(); try { def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); } catch (ClassNotFoundException ex) { throw new IllegalStateException( \u0026#34;Cannot load optional framework class: \u0026#34; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); } def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 注册EventListenerMethodProcessor类型的BeanDefinition，用来处理@EventListener注解的 if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); } // 注册DefaultEventListenerFactory类型的BeanDefinition，用来处理@EventListener注解的 if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME)); } return beanDefs; } 第7-18行：向容器上下文中注入AnnotationAwareOrderComparator和ContextAnnotationAutowireCandidateResolver两个组件，都是跟依赖注入功能相关，第一个组件在上篇文章介绍扫描器时已经详细介绍了，这里就不赘述了，第二个组件会在解析依赖注入功能时再详细介绍。 第23-72行：向容器中手动设置各种类型的postProcessor后置扩展点处理器作为infra组件： org.springframework.beans.factory.config.BeanFactoryPostProcessor：ConfigurationClassPostProcessor、EventListenerMethodProcessor org.springframework.beans.factory.config.BeanPostProcessor：AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、PersistenceAnnotationBeanPostProcessor org.springframework.context.event.EventListenerFactory:DefaultEventListenerFactory。 这些基础的内置infra扩展点处理器后续会在容器初始化的不同生命周期阶段发挥作用，到时用到再进行详细分析。Spring在扫描用户自定义的bean前会预先调用registerPostProcessor方法进行手动注册。具体的注册逻辑又是怎样的呢？\n1 2 3 4 5 6 7 8 9 org.springframework.context.annotation.AnnotationConfigUtils#registerPostProcessor private static BeanDefinitionHolder registerPostProcessor( BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) { definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(beanName, definition); // BeanDefinitinoMap return new BeanDefinitionHolder(definition, beanName); } 这里我们先简单的看一下infra的beanDefinition注册步骤，详细的注册逻辑在后面注册用户自定义的bean时再分析。首先这些infra的组件beanDefinition会被创建成org.springframework.beans.factory.support.RootBeanDefinition，RootBeanDefinition是可以直接被容器拿来进行IOC的beanDefinition类型，无须再进行其他的解析处理，相当于是已经解析后的成品beanDefinition，其他类型的beanDefinition在IOC时最后都会被转换（进一步解析）成RootBeanDefinition，这些不同类型的beanDefinition我会在新的文章中详细介绍。\nbeanDefinition的类型会被设置ROLE_INFRASTRUCTURE表示当前bean的类型是基础组件。\nROLE_APPLICATION：表示bean是应用组成级别的，通常用户自定义的bean会被设置成此角色 ROLE_SUPPORT：表示bean是支持配置级别的 ROLE_INFRASTRUCTURE：通常表示内部功能级别的bean，这些bean不会被用户使用 真正进行注册beanDefinition则是调用容器的registerBeanDefinition将definition注册到容器的BeanDefinitinoMap中去。\n注册用户自定义beanDefinition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 protected Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, \u0026#34;At least one base package must be specified\u0026#34;); Set\u0026lt;BeanDefinitionHolder\u0026gt; beanDefinitions = new LinkedHashSet\u0026lt;\u0026gt;(); for (String basePackage : basePackages) { Set\u0026lt;BeanDefinition\u0026gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { // 解析@Lazy、@Primary、@DependsOn、@Role、@Description AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } // 检查Spring容器中是否已经存在该beanName if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 第4-6行：扫描basePackage下的资源文件生成BeanDefinition，findCandidateComponents找出候选的BeanDefinition是核心的扫描解析逻辑，下面详细分析。 第9-10行：解析bean的scope属性 第12行：调用BeanNameGenerator给bean生成名字 解析资源文件生成BeanDefinition 1 2 3 4 5 6 7 8 9 10 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents public Set\u0026lt;BeanDefinition\u0026gt; findCandidateComponents(String basePackage) { if (this.componentsIndex != null \u0026amp;\u0026amp; indexSupportsIncludeFilters()) { return addCandidateComponentsFromIndex(this.componentsIndex, basePackage); } else { return scanCandidateComponents(basePackage); } } 第4-6行：使用索引扫描BeanDefinition 第8行：通过扫描资源文件即用户的class文件生成BeanDefinition 索引扫描 TODO\n扫描候选组件 将资源文件解析成BeanDefinition的功能主要由scanCandidateComponents方法完成。入参basePackage是包路径，返回值为解析的BeanDefinition集合。源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 private Set\u0026lt;BeanDefinition\u0026gt; scanCandidateComponents(String basePackage) { Set\u0026lt;BeanDefinition\u0026gt; candidates = new LinkedHashSet\u0026lt;\u0026gt;(); try { // 获取basePackage下所有的文件资源 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + \u0026#39;/\u0026#39; + this.resourcePattern; Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(\u0026#34;Scanning \u0026#34; + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // excludeFilters、includeFilters判断 if (isCandidateComponent(metadataReader)) { // @Component--\u0026gt;includeFilters判断 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\u0026#34;Identified candidate component class: \u0026#34; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\u0026#34;Ignored because not a concrete top-level class: \u0026#34; + resource); } } } else { if (traceEnabled) { logger.trace(\u0026#34;Ignored because not matching any filter: \u0026#34; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( \u0026#34;Failed to read candidate component class: \u0026#34; + resource, ex); } } else { if (traceEnabled) { logger.trace(\u0026#34;Ignored because not readable: \u0026#34; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\u0026#34;I/O failure during classpath scanning\u0026#34;, ex); } return candidates; } 第5-8行：拼接类路径地址，最终得到classpath*:xxx/**/*.class这样的一个类似通配符的地址，xxx是你传入的包名，可以通过@ComponentScan注解指定。getResourcePatternResolver()会获取ResourcePatternResolver进行多个资源的解析，如果扫描器设置了resourcePatternResolver就直接使用，没有则使用AnnotationConfigApplicationContext最为默认的ResourcePatternResolver进行资源解析。具体的资源解析器相关功能可参照Spring源码BeanDefinition解析之ClassPathBeanDefinitionScanner这篇文章相关章节。\n第18-20行:从MetadataReaderFactory获取MetadataReader，默认使用CachingMetadataReaderFactory，CachingMetadataReaderFactory会使用Map\u0026lt;Resource, MetadataReader\u0026gt; metadataReaderCache作为缓存存储Resource跟MetadataReader，Spring默认使用org.springframework.core.type.classreading.SimpleMetadataReader。isCandidateComponent方法使用excludeFilters、includeFilters、conditionEvaluator判断扫描到的资源文件是否匹配，includeFilters默认会匹配含有@Component的资源。过滤器和条件注解的具体使用参考Spring源码BeanDefinition解析之ClassPathBeanDefinitionScanner这篇文章相关章节。\n第21-28行：将上述步骤匹配的资源封装成org.springframework.context.annotation.ScannedGenericBeanDefinition，24行又有一个isCandidateComponent方法，会进一步在判断扫描得到的资源是否符合一个候选组件，符合的话最终加到candidates集合中返回出去。看下这个isCandidateComponent的主要逻辑：\n1 2 3 4 5 6 7 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(org.springframework.beans.factory.annotation.AnnotatedBeanDefinition) protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); return (metadata.isIndependent() \u0026amp;\u0026amp; (metadata.isConcrete() || (metadata.isAbstract() \u0026amp;\u0026amp; metadata.hasAnnotatedMethods(Lookup.class.getName())))); } 这里判断符合候选组件的条件需要同时满足两个条件：\n候选组件是独立的类，如果是嵌套的内部类那必须是静态内部类。 候选组件是具体的类，即非接口非抽象类；或者是抽象类的话，方法上必须含有Lookup注解。 scanCandidateComponents方法筛选候选组件时为什么要分两个isCandidateComponent方法判断呢而不是写在一个方法里面呢？第一个判断方法主要是进行外部的exclude和include过滤器的筛选，并不进行组件本身的属性条件筛选，第二个判断方法才针对类的自身属性进行具体的条件判断，诸如类的结构、是否为接口或抽象类等条件。注意这两个判断方法都使用了protected关键字，是可以被子类重写的，如果你有自己的特殊扫描逻辑，可以通过重写这两个判断方法使用你自己的筛选逻辑。\nscope属性解析 扫描解析出候选的BeanDefinition后，doScan方法会使用org.springframework.context.annotation.ScopeMetadataResolver解析scope相关的属性并设置到BeanDefinition中去。\n1 2 3 4 // 解析scope属性元数据信息 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); // 设置BeanDefinition是singleton还是prototype candidate.setScope(scopeMetadata.getScopeName()); 这里使用ScopeMetadataResolver的实现org.springframework.context.annotation.AnnotationScopeMetadataResolver看下scope的元数据解析是如何实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) { ScopeMetadata metadata = new ScopeMetadata(); if (definition instanceof AnnotatedBeanDefinition) { AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType); if (attributes != null) { metadata.setScopeName(attributes.getString(\u0026#34;value\u0026#34;)); ScopedProxyMode proxyMode = attributes.getEnum(\u0026#34;proxyMode\u0026#34;); if (proxyMode == ScopedProxyMode.DEFAULT) { proxyMode = this.defaultProxyMode; } metadata.setScopedProxyMode(proxyMode); } } return metadata; } 第6-8行：获取AnnotatedBeanDefinition的元数据信息AnnotationMetadata，通过注解工具类AnnotationConfigUtils获取Scope属性的元数据信息AnnotationAttributes，AnnotationAttributes实际上是一个LinkedHashMap\u0026lt;String, Object\u0026gt;，key就是注解中的属性名称，value就是注解中的属性值。所以一个AnnotationAttributes实际就是一个注解的元数据信息集合。\n第9-16行：有了Scope属性的元数据信息，提取value值和proxyMode值设置到ScopeMetadata中。Scope注解中的proxyMode值是个枚举值，用于指定在创建代理对象时使用的代理模式，它有三种可能的取值：\nproxyMode = ScopedProxyMode.NO：这表示不要使用代理来包装bean，直接返回原始的bean对象，如果不设置proxyMode属性，默认值就是这个。 proxyMode = ScopedProxyMode.INTERFACES：这表示使用JDK动态代理来包装bean，并且只暴露bean实现的接口。 proxyMode = ScopedProxyMode.TARGET_CLASS：这表示使用CGLIB来包装bean，并保留类的结构。 beanName生成规则 在doScan方法中，使用org.springframework.beans.factory.support.BeanNameGenerator#generateBeanName生成bean的名称，BeanNameGenerator接口有多个实现，这里使用org.springframework.context.annotation.AnnotationBeanNameGenerator作为示例参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 org.springframework.context.annotation.AnnotationBeanNameGenerator#generateBeanName public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) { if (definition instanceof AnnotatedBeanDefinition) { // 获取注解所指定的beanName String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition); if (StringUtils.hasText(beanName)) { // Explicit bean name found. return beanName; } } // Fallback: generate a unique default bean name. return buildDefaultBeanName(definition, registry); } 第2-9行：如果类使用了注解配置，则使用注解方式生成beanName。 第11行：非注解方式定义bean，则使用默认的beanName生成规则。 注解方式生成beanName 如果我们使用了@Component、@Controller、@Service、@Repository这些注解定义bean，并且通过value属性显示定义了beanName,那么Spring通过determineBeanNameFromAnnotation方法解析beanName，具体逻辑如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 org.springframework.context.annotation.AnnotationBeanNameGenerator#determineBeanNameFromAnnotation protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) { AnnotationMetadata amd = annotatedDef.getMetadata(); Set\u0026lt;String\u0026gt; types = amd.getAnnotationTypes(); String beanName = null; for (String type : types) { AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type); if (attributes != null) { Set\u0026lt;String\u0026gt; metaTypes = this.metaAnnotationTypesCache.computeIfAbsent(type, key -\u0026gt; { Set\u0026lt;String\u0026gt; result = amd.getMetaAnnotationTypes(key); return (result.isEmpty() ? Collections.emptySet() : result); }); if (isStereotypeWithNameValue(type, metaTypes, attributes)) { Object value = attributes.get(\u0026#34;value\u0026#34;); if (value instanceof String) { String strVal = (String) value; if (StringUtils.hasLength(strVal)) { if (beanName != null \u0026amp;\u0026amp; !strVal.equals(beanName)) { throw new IllegalStateException(\u0026#34;Stereotype annotations suggest inconsistent \u0026#34; + \u0026#34;component names: \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; versus \u0026#39;\u0026#34; + strVal + \u0026#34;\u0026#39;\u0026#34;); } beanName = strVal; } } } } } return beanName; } 第2-3行：获取类上的注解元数据信息和所有的注解全限定名称 第6-11行：找出这些注解的属性元信息，如果注解是复合注解，比如@Service、@Controller这种那么再找出这些复合注解的元注解信息，isStereotypeWithNameValue根据这些数据判断注解中是否包含Component的信息，如果使用了@Service、@Controller、@Component注解并且value属性设置了beanName那么则直接使用。 1 2 3 4 5 6 7 8 9 10 11 protected boolean isStereotypeWithNameValue(String annotationType, Set\u0026lt;String\u0026gt; metaAnnotationTypes, @Nullable Map\u0026lt;String, Object\u0026gt; attributes) { // 当前注解是否直接使用Component boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) || // 元注解中是否包含Component metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) || annotationType.equals(\u0026#34;javax.annotation.ManagedBean\u0026#34;) || annotationType.equals(\u0026#34;javax.inject.Named\u0026#34;); return (isStereotype \u0026amp;\u0026amp; attributes != null \u0026amp;\u0026amp; attributes.containsKey(\u0026#34;value\u0026#34;)); } 默认方式生成beanName 如果没有使用注解方式定义bean或者使用了注解（@Component、@Controller、@Service、@Repository）但是没有在value属性中显示指定beanName，那么会走默认生成beanName的逻辑，源码位于org.springframework.context.annotation.AnnotationBeanNameGenerator#buildDefaultBeanName(org.springframework.beans.factory.config.BeanDefinition)：\n1 2 3 4 5 6 protected String buildDefaultBeanName(BeanDefinition definition) { String beanClassName = definition.getBeanClassName(); Assert.state(beanClassName != null, \u0026#34;No bean class name set\u0026#34;); String shortClassName = ClassUtils.getShortName(beanClassName); return Introspector.decapitalize(shortClassName); } 第2-4行：获取类的名称，没有全限定名 第5行：真正生成beanName的方法位于java.beans.Introspector#decapitalize 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 java.beans.Introspector#decapitalize public static String decapitalize(String name) { if (name == null || name.length() == 0) { return name; } // 第一和第二个字母都是大写 if (name.length() \u0026gt; 1 \u0026amp;\u0026amp; Character.isUpperCase(name.charAt(1)) \u0026amp;\u0026amp; Character.isUpperCase(name.charAt(0))){ return name; } // 首字母小写 char chars[] = name.toCharArray(); chars[0] = Character.toLowerCase(chars[0]); return new String(chars); } 如果是驼峰的命名方式，会把首字母转小写，比如FooBah变成fooBah，X变成x;如果首字母跟第二个字母都是大写这种，则返回原名称不会转换，比如URL还是保持URL不会转换。\nbeanDefinition后置处理 在完成beanName的生成后，扫描器会进行beanDefinition的后置处理，主要是进行一些一些属性的默认赋值和一些通用注解的解析赋值，如@Lazy、@Primary、@DependsOn、@Role、@Description。\n属性默认赋值 doScan方法会判断当前候选组件的BeanDefinition是否为AbstractBeanDefinition，是则进行属性的默认赋值。AbstractBeanDefinition的子类有很多，RootBeanDefinition、ChildBeanDefinition、ScannedGenericBeanDefinition、AnnotatedGenericBeanDefinition这些都是。扫描器刚通过scanCandidateComponents扫出来的候选组件都是ScannedGenericBeanDefinition，所以默认会走postProcessBeanDefinition进行属性赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 org.springframework.context.annotation.ClassPathBeanDefinitionScanner // 如果候选组件为AbstractBeanDefinition进行属性默认值赋值 if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } // ClassPathBeanDefinitionScanner创建时默认会初始化beanDefinitionDefaults private BeanDefinitionDefaults beanDefinitionDefaults = new BeanDefinitionDefaults(); protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) { // 设置BeanDefinition的默认值 beanDefinition.applyDefaults(this.beanDefinitionDefaults); // AutowireCandidate表示某个Bean能否被用来做依赖注入 if (this.autowireCandidatePatterns != null) { beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName)); } } 第13行：主要就是对BeanDefinition的部分属性进行统一默认赋值，通过将ClassPathBeanDefinitionScanner的属性beanDefinitionDefaults对象中的属性赋值到候选的beanDefinition中去,ClassPathBeanDefinitionScanner创建时默认会初始化beanDefinitionDefaults，也可显示调用ClassPathBeanDefinitionScanner的setBeanDefinitionDefaults进行设置。默认都有哪些属性值呢？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 org.springframework.beans.factory.support.AbstractBeanDefinition#applyDefaults public void applyDefaults(BeanDefinitionDefaults defaults) { // 设置lazyInit属性 Boolean lazyInit = defaults.getLazyInit(); if (lazyInit != null) { setLazyInit(lazyInit); } // 设置autowireMode属性 默认为AUTOWIRE_NO setAutowireMode(defaults.getAutowireMode()); // 设置dependencyCheck属性，默认DEPENDENCY_CHECK_NONE setDependencyCheck(defaults.getDependencyCheck()); // 设置bean初始化时的hook方法 setInitMethodName(defaults.getInitMethodName()); // 设置enforceInitMethod属性默认true setEnforceInitMethod(false); // 设置bean销毁时的hook方法 setDestroyMethodName(defaults.getDestroyMethodName()); // 设置enforceDestroyMethod属性 默认true setEnforceDestroyMethod(false); } 第16~18行：设置autowireCandidate属性，autowireCandidate属性是用来设置自动装配候选模式的，表示当前bean是否可以被其他bean自动装配，默认为true。autowireCandidatePatterns属性是一组类似正则的匹配规则，允许你指定一组模式，用于匹配bean的名称，以确定哪些bean应该被视为自动装配的候选bean。比如autowireCandidatePatterns设置为[Service],那些名称以Service结尾的bean会被考虑为自动装配的候选项，如果当前bean是userService，autowireCandidate属性会被设置成true。simpleMatch方法还能匹配其他诸如\u0026quot;xxx\u0026quot;, \u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;xxx*yyy\u0026quot;的模式。 AnnotatedBeanDefinition注解解析 扫描器扫描解析出的候选组件为AnnotatedBeanDefinition类型，会进行@Lazy、@Primary、@DependsOn、@Role、@Description属性的值解析，代码比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) { // 解析Lazy注解 AnnotationAttributes lazy = attributesFor(metadata, Lazy.class); if (lazy != null) { abd.setLazyInit(lazy.getBoolean(\u0026#34;value\u0026#34;)); } else if (abd.getMetadata() != metadata) { lazy = attributesFor(abd.getMetadata(), Lazy.class); if (lazy != null) { abd.setLazyInit(lazy.getBoolean(\u0026#34;value\u0026#34;)); } } // 解析Primary if (metadata.isAnnotated(Primary.class.getName())) { abd.setPrimary(true); } // 解析DependsOn AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class); if (dependsOn != null) { abd.setDependsOn(dependsOn.getStringArray(\u0026#34;value\u0026#34;)); } // 解析Role AnnotationAttributes role = attributesFor(metadata, Role.class); if (role != null) { abd.setRole(role.getNumber(\u0026#34;value\u0026#34;).intValue()); } // 解析Description AnnotationAttributes description = attributesFor(metadata, Description.class); if (description != null) { abd.setDescription(description.getString(\u0026#34;value\u0026#34;)); } } 注册beanDefinition 在完成了上面的资源文件扫描解析、属性初始化赋值解析、beanName生成等步骤后，扫描器才开始进行真正的beanDefinition注册。在开始之前，Spring首先会根据beanName检测容器中是否已经注册过了相应的bean，没有就进行注册，如果检测到容器中已经有了呢，对于名称冲突的bean该具体如何处理呢？ClassPathBeanDefinitionScanner#checkCandidate方法中给出了具体的答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException { // 容器中没有当前beanName，返回true，后续开始真正的注册beanDefinition步骤 if (!this.registry.containsBeanDefinition(beanName)) { return true; } // 获取容器中已经存在的冲突的BeanDefinition BeanDefinition existingDef = this.registry.getBeanDefinition(beanName); BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition(); if (originatingDef != null) { existingDef = originatingDef; } // 是否兼容，如果兼容返回false表示不会重新注册到Spring容器中，如果不冲突则会抛异常。 if (isCompatible(beanDefinition, existingDef)) { return false; } throw new ConflictingBeanDefinitionException(\u0026#34;Annotation-specified bean name \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; for bean class [\u0026#34; + beanDefinition.getBeanClassName() + \u0026#34;] conflicts with existing, \u0026#34; + \u0026#34;non-compatible bean definition of same name and class [\u0026#34; + existingDef.getBeanClassName() + \u0026#34;]\u0026#34;); } checkCandidate方法中，通过beanName查看容器中是否已经存在注册过了的beanDefinition，没有注册就对外返回false，后续进行真正的beanDefinition步骤实现。\n如果检测到已经存在相同beanName的冲突的bean，isCompatible方法进行兼容判断，不兼容，Spring就抛出ConflictingBeanDefinitionException运行时异常中断Spring的启动，告诉用户具体的冲突bean的类名称进行检查处理。\n如果需要兼容，checkCandidate方法返回false,使用新的beanDefinition注册以覆盖先前注册过的beanDefinition。\n兼容判断冲突的bean 1 2 3 4 5 protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) { return (!(existingDefinition instanceof ScannedGenericBeanDefinition) || // explicitly registered overriding bean (newDefinition.getSource() != null \u0026amp;\u0026amp; newDefinition.getSource().equals(existingDefinition.getSource())) || // scanned same file twice newDefinition.equals(existingDefinition)); // scanned equivalent class twice } isCompatible方法主要通过三个条件判断是否兼容,任意满足其中一个就进行兼容。\n!(existingDefinition instanceof ScannedGenericBeanDefinition)：现有的bean定义不是沟通过扫描机制得到的,比如手动注册的,那么第二次注册时就进行兼容,使用扫描得到的beanDefinition覆盖。Spring会保证扫描的bean定义优先级高于手动的。 newDefinition.getSource() != null \u0026amp;\u0026amp; newDefinition.getSource().equals(existingDefinition.getSource())：两次扫描的资源文件是一样的第二次覆盖第一次 newDefinition.equals(existingDefinition)：扫描了bean Class两次。 BeanDefinitionHolder注册 经过兼容判断后,确实需要进行注册bean定义则执行如下逻辑：\n1 2 3 4 5 6 7 8 // 创建BeanDefinitionHolder BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册 registerBeanDefinition(definitionHolder, this.registry); 第2行：使用扫描得到的BeanDefinition和beanName创建BeanDefinitionHolder。BeanDefinitionHolder具体是什么呢？ 第3~4行：如果bean指定了@Scope中的proxyMode属性为ScopedProxyMode.INTERFACES或ScopedProxyMode.TARGET_CLASS,需要对BeanDefinition做一些特殊处理设置。 第5行：加入扫描的bean定义集合Set中去对外返回 第8行：使用definitionHolder进行真正的注册bean定义。 BeanDefinitionHolder Spring对bean定义既然已经定义了父接口BeanDefinition,为啥不直接使用BeanDefinition进行注册呢,还要再wrap一个BeanDefinitionHolder进行注册呢？\n1 2 3 4 5 6 7 8 9 10 11 public class BeanDefinitionHolder implements BeanMetadataElement { private final BeanDefinition beanDefinition; private final String beanName; @Nullable private final String[] aliases; ... } 看下BeanDefinitionHolder的属性其实是对BeanDefinition的wrap,它持有BeanDefinition和beanName,而且多了一个别名的属性,允许bean拥有多个别名。\nBeanDefinitionRegistry注册bean定义 解析器中最终实现的注册的组件就是通过BeanDefinitionRegistry#registerBeanDefinition完成的,这就是bean定义的容器。看下BeanDefinitionRegistry接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public interface BeanDefinitionRegistry extends AliasRegistry { // 使用beanName和beanDefinition进行注册 void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; // 删除指定beanName的bean定义 void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; // 获取指定beanName的bean定义 BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; // 检查是否包含指定的bean定义 boolean containsBeanDefinition(String beanName); // 返回所有注册bean定义的beanName String[] getBeanDefinitionNames(); // 返回注册bean定义个数 int getBeanDefinitionCount(); // beanName是否被使用了 boolean isBeanNameInUse(String beanName); } public interface AliasRegistry { // 使用beanName和alias注册 void registerAlias(String name, String alias); // 删除指定别名的bean void removeAlias(String alias); // 给定的beanName是否是别名 boolean isAlias(String name); // 获取beanName的别名 String[] getAliases(String name); } BeanDefinitionRegistry继承了父接口AliasRegistry,这两个接口据中定义了使用beanName、alias进行bean的增删查等一系列方法。 Spring中的具体实现有哪些呢？ 大部分的高级容器都实现了这两个接口,那么注册到扫描器中的BeanDefinitionRegistry具体实现又是什么呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public AnnotationConfigApplicationContext() { StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(\u0026#34;spring.context.annotated-bean-reader.create\u0026#34;); // 额外会创建StandardEnvironment this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); // 将AnnotationConfigApplicationContext上下文作为bean定义容器 this.scanner = new ClassPathBeanDefinitionScanner(this); } // ClassPathBeanDefinitionScanner扫描器构造函数 public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader) { Assert.notNull(registry, \u0026#34;BeanDefinitionRegistry must not be null\u0026#34;); // 构造函数传入bean定义容器 this.registry = registry; if (useDefaultFilters) { registerDefaultFilters(); } setEnvironment(environment); setResourceLoader(resourceLoader); } Spring在初始化上下文时将自身AnnotationConfigApplicationContext作为registry设置到了扫描器中去。\n既然弄清楚了registry的具体实现,在回到doScan方法中看具体的注册实现源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan protected Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages){ if (checkCandidate(beanName, candidate)){ // 注册bean定义 registerBeanDefinition(definitionHolder, this.registry); } } protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) { BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry); } org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { // 使用beanName注册 String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果存在别名使用别名注册 String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { registry.registerAlias(beanName, alias); } } } 第8~9行：使用beanName和beanDefinition注册到registry中去。 第12~17行：如果bean存在别名,则将beanName和别名也注册到registry中。 知道了registry的真正实现是AnnotationConfigApplicationContext,那么看下registerBeanDefinition的具体实现： 1 2 3 4 5 6 7 8 9 org.springframework.context.support.GenericApplicationContext#registerBeanDefinition private final DefaultListableBeanFactory beanFactory; public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { // 具体注册委托给了DefaultListableBeanFactory this.beanFactory.registerBeanDefinition(beanName, beanDefinition); } AnnotationConfigApplicationContext并没有直接实现BeanDefinitionRegistry#registerBeanDefinition方法,而是继承了父类GenericApplicationContext#registerBeanDefinition,在GenericApplicationContext#registerBeanDefinition真正的实现逻辑委托给了低级容器DefaultListableBeanFactory进行实现。\nDefaultListableBeanFactory使用beanName注册bean定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // key为beanName value为BeanDefinition private final Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(256); private volatile List\u0026lt;String\u0026gt; beanDefinitionNames = new ArrayList\u0026lt;\u0026gt;(256); public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \u0026#34;Validation of bean definition failed\u0026#34;, ex); } } BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); if (existingDefinition != null) { // 默认是允许BeanDefinition覆盖的 ... this.beanDefinitionMap.put(beanName, beanDefinition); } else { if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List\u0026lt;String\u0026gt; updatedDefinitions = new ArrayList\u0026lt;\u0026gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; removeManualSingletonName(beanName); } } else { // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); removeManualSingletonName(beanName); } ... } ... } 第4~12行：bean定义校验,主要对bean需要重写的方法进行校验和预处理。 第14~19行：beanDefinitionMap中已经注册过了,默认进行覆盖注册 第26~42行：往beanDefinitionMap、beanDefinitionNames添加新的bean bean定义的注册整个流程的细节还是有点复杂的,这里简化了逻辑,只分析了核心部分代码。注册的核心就是往beanDefinitionMap、beanDefinitionNames新增了新的bean的相关信息。\nDefaultListableBeanFactory使用别名注册bean定义 1 2 3 4 5 6 7 8 org.springframework.context.support.GenericApplicationContext#registerAlias private final DefaultListableBeanFactory beanFactory; public void registerAlias(String beanName, String alias) { // GenericApplicationContext委托beanFactory进行别名注册 this.beanFactory.registerAlias(beanName, alias); } 同样的,AnnotationConfigApplicationContext也没有直接实现AliasRegistry#registerAlias,父类GenericApplicationContext实现了AliasRegistry#registerAlias。最终委托给了低级容器DefaultListableBeanFactory进行别名的注册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 org.springframework.core.SimpleAliasRegistry#registerAlias // key为别名 value为beanName private final Map\u0026lt;String, String\u0026gt; aliasMap = new ConcurrentHashMap\u0026lt;\u0026gt;(16); public void registerAlias(String name, String alias) { synchronized (this.aliasMap) { if (alias.equals(name)) { this.aliasMap.remove(alias); if (logger.isDebugEnabled()) { logger.debug(\u0026#34;Alias definition \u0026#39;\u0026#34; + alias + \u0026#34;\u0026#39; ignored since it points to same name\u0026#34;); } } else { String registeredName = this.aliasMap.get(alias); if (registeredName != null) { if (registeredName.equals(name)) { // An existing alias - no need to re-register return; } if (!allowAliasOverriding()) { throw new IllegalStateException(\u0026#34;Cannot define alias \u0026#39;\u0026#34; + alias + \u0026#34;\u0026#39; for name \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;: It is already registered for name \u0026#39;\u0026#34; + registeredName + \u0026#34;\u0026#39;.\u0026#34;); } if (logger.isDebugEnabled()) { logger.debug(\u0026#34;Overriding alias \u0026#39;\u0026#34; + alias + \u0026#34;\u0026#39; definition for registered name \u0026#39;\u0026#34; + registeredName + \u0026#34;\u0026#39; with new target name \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); } } checkForAliasCircle(name, alias); this.aliasMap.put(alias, name); if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Alias definition \u0026#39;\u0026#34; + alias + \u0026#34;\u0026#39; registered for name \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); } } } } 第9~14行：别名和beanName一致,那就忽略不需要记录 第16~30行：已经存在beanName和别名的映射关系了直接返回;如果别名先前映射了其他的beanName是否允许覆盖判断。 第31行：检查beanName和别名是否存在循环引用的关系。 直接循环引用：比如有个userBean,别名为userAlias,已经存储了userAlias-\u0026gt;user的映射关系,此时别名注册时希望记录user-\u0026gt;userAlias的映射,这时就会检测到相互引用,Spring抛出IllegalStateException异常 间接循环引用：比如已经存储了userAlias-\u0026gt;user-\u0026gt;u1的映射关系,此时希望存储u1-\u0026gt;userAlias的引用,也是不允许会抛出异常的 第32行：向aliasMap中写入别名与beanName的映射关系 ","date":"2023-01-25T00:00:00Z","image":"https://example.com/p/classpathbeandefinitionscanner%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/bd_hu1728d03202da6945cada7b02a8c1392a_152544_120x120_fill_q75_box_smart1.jpeg","permalink":"https://example.com/p/classpathbeandefinitionscanner%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","title":"ClassPathBeanDefinitionScanner主流程源码解析"},{"content":"主要是介绍Spring framework中在解析BeanDefinition模块时用到的ClassPathBeanDefinitionScanner组件以及涉及的一些底层API。\n前言 在Spring中我们可以通过编程式的方式显示声明定义BeanDefinition：\n1 2 3 4 5 // 创建一个Spring容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); // 获取容器中名为userService的BeanDefinition BeanDefinition userService = applicationContext.getBeanDefinition(\u0026#34;userService\u0026#34;); System.out.println(userService); ClassPathBeanDefinitionScanner 扫描器是什么 bean定义扫描解析器用于在classpath下发现候选的bean,使用指定的BeanFactory或者ApplicationContext注册bean定义BeanDefinition。\n上面是官方源码中的注释，其实写的很清楚了，扫描器通过入参classpath使用容器进行bean定义的注册，使用相关的filter进行过滤注册，默认过滤器会对包含如下注解的类进行扫描解析:\norg.springframework.stereotype.Component @Component org.springframework.stereotype.Repository @Repository org.springframework.stereotype.Service @Service org.springframework.stereotype.Con--troller @Controller 看下相关的构造函数API：\n1 2 3 4 5 6 7 8 9 10 // 构造函数中传入容器 public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { // 使用默认过滤器 this(registry, true); } // 构造函数传入容器和是否使用默认过滤器 public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) { this(registry, useDefaultFilters, getOrCreateEnvironment(registry)); } 扫描器根据指定的包路径比如在@ComponentScan注解中指定，通过资源解析器ResourcePatternResolver扫描该路径下的class文件,最终通过元数据读取器MetadataReader解析成一个一个的BeanDefinition注册到容器上下文中去，解析时候可以设置相应的规则filter,比如设置哪些class文件不需要解析又有哪些需要。\nResourceLoader Spring中如何读取资源文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 读取文件资源 AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); Resource resource = ctx.getResource(\u0026#34;file://D:\\\\githu\\\\spring-framework-5.3.10\\\\tuling\\\\src\\\\main\\\\java\\\\com\\\\demo\\\\service\\\\UserService.java\u0026#34;); System.out.println(resource.contentLength()); System.out.println(resource.getFilename()); // 读取网络资源 Resource resource1 = ctx.getResource(\u0026#34;https://www.baidu.com\u0026#34;); System.out.println(resource1.contentLength()); System.out.println(resource1.getURL()); // 读取类路径资源 Resource resource2 = ctx.getResource(\u0026#34;classpath:spring.xml\u0026#34;); System.out.println(resource2.contentLength()); System.out.println(resource2.getURL()); 容器上下文AnnotationConfigApplicationContext会根据不同的schema读取不同类型的资源，读取资源的方法一共有2个，org.springframework.context.support.GenericApplicationContext#getResource和org.springframework.context.support.GenericApplicationContext#getResources,前者读取一个而后者可以读取多个资源。\n读取单个资源 这里截取了AnnotationConfigApplicationContext的资源相关接口的继承图，最顶层的接口org.springframework.core.io.ResourceLoader：\n1 2 3 4 5 6 7 8 9 10 11 public interface ResourceLoader { /** 类路径前缀: \u0026#34;classpath:\u0026#34;. */ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; // 读取单个资源 Resource getResource(String location); @Nullable ClassLoader getClassLoader(); } ResourceLoader接口定义了读取单个资源的方法getResource。AnnotationConfigApplicationContext并没有覆写getResource方法，继承了父类的GenericApplicationContext#getResource:\n1 2 3 4 5 6 public Resource getResource(String location) { if (this.resourceLoader != null) { return this.resourceLoader.getResource(location); } return super.getResource(location); } GenericApplicationContext其实也没有具体实现getResource方法，先判断是否自定义了resourceLoader，如果已经设置了则直接调用resourceLoader.getResource读取资源；如果没有则进一步调用父类DefaultResourceLoader#getResource方法。DefaultResourceLoader才是ResourceLoader接口的具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 org.springframework.core.io.DefaultResourceLoader#getResource public Resource getResource(String location) { Assert.notNull(location, \u0026#34;Location must not be null\u0026#34;); for (ProtocolResolver protocolResolver : getProtocolResolvers()) { Resource resource = protocolResolver.resolve(location, this); if (resource != null) { return resource; } } if (location.startsWith(\u0026#34;/\u0026#34;)) { return getResourceByPath(location); } else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // Try to parse the location as a URL... URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -\u0026gt; resolve as resource path. return getResourceByPath(location); } } } 第6-11行：自定义的org.springframework.core.io.ProtocolResolver资源协议解析器集合，Spring并没有默认实现，需要用户自己实现接口。当Spring中的默认资源解析器DefaultResourceLoader不满足资源解析条件时，可以自定义资源解析器作为扩展点，优点就是不需要实现ResourceLoader接口或者继承其他ResourceLoader的其他子类，相对灵活一些。\n第13-15行：如果资源路径时/开头，直接生成org.springframework.core.io.DefaultResourceLoader.ClassPathContextResource类型的资源。\n第16-18行：如果资源路径已classpath:开头，直接生成org.springframework.core.io.ClassPathResource类型的资源。\n第22-23行：生成URL类型的资源org.springframework.core.io.FileUrlResource和org.springframework.core.io.UrlResource。\n通过分析单个资源的解析逻辑，Spring主要使用ResourceLoader的默认实现DefaultResourceLoader作为单个资源解析的主要实现，如果不满足默认的解析规则，则可以通过自己实现ResourceLoader接口注入容器上下文或者自定义实现ProtocolResolver注册到DefaultResourceLoader两种方式实现。\n读取多个资源 AnnotationConfigApplicationContext的继承图上，ResourcePatternResolver接口继承了ResourceLoader接口，接口定义如下：\n1 2 3 4 5 6 7 public interface ResourcePatternResolver extends ResourceLoader { String CLASSPATH_ALL_URL_PREFIX = \u0026#34;classpath*:\u0026#34;; Resource[] getResources(String locationPattern) throws IOException; } ResourcePatternResolver接口扩展了ResourceLoader接口的资源解析能力，它提供了解析多个资源的方法getResources。跟解析单个资源一样，AnnotationConfigApplicationContext并没有重写getResources方法，复用了GenericApplicationContext#getResources方法：\n1 2 3 4 5 6 public Resource[] getResources(String locationPattern) throws IOException { if (this.resourceLoader instanceof ResourcePatternResolver) { return ((ResourcePatternResolver) this.resourceLoader).getResources(locationPattern); } return super.getResources(locationPattern); } 如果容器自定义了ResourcePatternResolver那就直接使用，如果没有则调用父类org.springframework.context.support.AbstractApplicationContext#getResources方法：\n1 2 3 4 5 private ResourcePatternResolver resourcePatternResolver; public Resource[] getResources(String locationPattern) throws IOException { return this.resourcePatternResolver.getResources(locationPattern); } AbstractApplicationContext的实现逻辑就是最终调用resourcePatternResolver完成多个资源的解析。那么AbstractApplicationContext是在哪初始化resourcePatternResolver属性的呢？\n1 2 3 4 5 6 7 8 9 org.springframework.context.support.AbstractApplicationContext public AbstractApplicationContext() { this.resourcePatternResolver = getResourcePatternResolver(); } protected ResourcePatternResolver getResourcePatternResolver() { return new PathMatchingResourcePatternResolver(this); } AbstractApplicationContext在构造方法中直接创建PathMatchingResourcePatternResolver作为ResourcePatternResolver作为资源解析器使用。\nPathMatchingResourcePatternResolver通过实现ResourcePatternResolver接口最终实现ResourceLoader的能力。\nMetadataReader 在Spring中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数据，所以Spring中对类的元数据做了抽象，并提供了一些工具类。 MetadataReader表示类的元数据读取器，默认实现类为SimpleMetadataReader。比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SimpleMetadataReaderFactory simpleMetadataReaderFactory = new SimpleMetadataReaderFactory(); // 构造一个MetadataReader MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(\u0026#34;com.demo.service.UserService\u0026#34;); // 得到一个ClassMetadata，并获取了类名 ClassMetadata classMetadata = metadataReader.getClassMetadata(); System.out.println(classMetadata.getClassName()); // 获取一个AnnotationMetadata，并获取类上的注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 类上是否包含@Component注解 可以递归检查 System.out.println(annotationMetadata.hasMetaAnnotation(Component.class.getName())); for (String annotationType : annotationMetadata.getAnnotationTypes()) { System.out.println(annotationType); } ExcludeFilter和IncludeFilter 如何在Spring中使用filter 这两个过滤器在ClassPathBeanDefinitionScanner扫描出包路径下的所有资源文件后，会使用这2个过滤器看是否符合其规则进一步决定是否要生成BeanDefinition。\n在Spring中用户如何自定义使用过滤器呢，比如下面的配置，表示扫描com.example包下面的类，排除所有标有@ExcludeComponent注解的类不会成为bean,即使这个类上标注有@Component;IncludeComponent类即使没有@Component注解也会被解析。\n1 2 3 4 5 6 7 @Configuration @ComponentScan(basePackages = \u0026#34;com.example\u0026#34;, excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {ExcludeComponent.class}), includeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {IncludeComponent.class})) public class AppConfig { // 配置类的其他内容 } FilterType分为：\nANNOTATION：表示是否包含某个注解 ASSIGNABLE_TYPE：表示是否是某个类 ASPECTJ：表示否是符合某个Aspectj表达式 REGEX：表示是否符合某个正则表达式 CUSTOM：自定义 哪里使用到filter 解析器具体是在哪里会使用到过滤器呢？下面是Spring中扫描器扫描的入口方法，在scanCandidateComponents方法中解析出包路径下的所有文件资源后会遍历进行过滤匹配，符合过滤条件的资源最后才会生成BeanDefinition。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents private Set\u0026lt;BeanDefinition\u0026gt; scanCandidateComponents(String basePackage) { Set\u0026lt;BeanDefinition\u0026gt; candidates = new LinkedHashSet\u0026lt;\u0026gt;(); // 获取basePackage下所有的文件资源 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + \u0026#39;/\u0026#39; + this.resourcePattern; Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); ... for (Resource resource : resources) { ... MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // excludeFilters、includeFilters判断 if (isCandidateComponent(metadataReader)) { // @Component--\u0026gt;includeFilters判断 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); if (isCandidateComponent(sbd)) { ... candidates.add(sbd); } ... } ... } return candidates; } 在isCandidateComponent中具体的过滤匹配逻辑，就是使用excludeFilters和includeFilters过滤器的match方法判断是否满足过滤条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException { for (TypeFilter tf : this.excludeFilters) { if (tf.match(metadataReader, getMetadataReaderFactory())) { return false; } } // 符合includeFilters的会进行条件匹配，通过了才是Bean，也就是先看有没有@Component，再看是否符合@Conditional for (TypeFilter tf : this.includeFilters) { if (tf.match(metadataReader, getMetadataReaderFactory())) { return isConditionMatch(metadataReader); } } return false; } Spring在创建上下文容器时默认会在扫描器中创建org.springframework.core.type.filter.AnnotationTypeFilter类型的includeFilters，默认对含有@Component的组件进行解析匹配 而使用了@ComponentScan定义的过滤器最后则会生成org.springframework.core.type.filter.AssignableTypeFilter类型的过滤器添加到容器中进行过滤匹配 TypeFilter 在顶层接口TypeFilter中，使用metaData定义了匹配行为规则：\n1 2 3 4 public interface TypeFilter { // 过滤器匹配方法 boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException; } AnnotationTypeFilter和AssignableTypeFilter都继承了抽象类org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#macth方法，本身没有对macth方法做具体的实现，macth方法的主体流程实现则是由抽象类AbstractTypeHierarchyTraversingFilter负责，不同的匹配子逻辑则是交由子类AnnotationTypeFilter和AssignableTypeFilter进行了实现，典型的模板方法设计模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#match(org.springframework.core.type.classreading.MetadataReader, org.springframework.core.type.classreading.MetadataReaderFactory) public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { // AnnotationTypeFilter实现macthSelf方法 // 使用metadataReader判断是否包含指定注解 if (matchSelf(metadataReader)) { return true; } // AssignableTypeFilter实现了matchClassName方法 // 匹配类名是否一致 ClassMetadata metadata = metadataReader.getClassMetadata(); if (matchClassName(metadata.getClassName())) { return true; } ... return false; } AnnotationTypeFilter 1 2 3 4 5 6 7 8 9 10 // 目标注解类型 private final Class\u0026lt;? extends Annotation\u0026gt; annotationType; protected boolean matchSelf(MetadataReader metadataReader) { // 获取类的元数据 AnnotationMetadata metadata = metadataReader.getAnnotationMetadata(); // 判断当前类上是否包含目标注解 return metadata.hasAnnotation(this.annotationType.getName()) || (this.considerMetaAnnotations \u0026amp;\u0026amp; metadata.hasMetaAnnotation(this.annotationType.getName())); } AbstractTypeHierarchyTraversingFilter#matchSelf方法默认返回false,AnnotationTypeFilter重写了matchSelf方法，使用metadataReader获取当前资源的元数据信息判断是否包含目标注解（默认@Component），metadata.hasMetaAnnotation方法会递归地去解析资源上是否包含目标注解。什么意思呢？比如当前类上使用了@Service注解，metadata.hasMetaAnnotation会检查@Service注解里面是否有@Component注解。\nAssignableTypeFilter 1 2 3 4 5 6 // 目标类名称 private final Class\u0026lt;?\u0026gt; targetType; // 匹配目标类名称 protected boolean matchClassName(String className) { return this.targetType.getName().equals(className); } org.springframework.core.type.filter.AssignableTypeFilter#matchClassName方法比较简单，拿目标类名称与当前资源解析器获取的类名称匹配下，targetType就是在@ComponentScan中注定过滤匹配类型。\nOrderComparator Spring在依赖注入时被依赖的的组件有多个时比如依赖一个List时需要对其进行优先级排序后进行注入,那么有哪些方式可以声明优先级顺序呢？可以实现org.springframework.core.PriorityOrdered#getOrder、实现org.springframework.core.Ordered#getOrder、或者直接使用org.springframework.core.annotation.Order注解指定顺序，那么这些方式的执行顺序又是怎样的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // A实现了PriorityOrdered public class A implements PriorityOrdered { @Override public int getOrder() { return 0; } } // B实现了Order接口 public class B implements Ordered { @Override public int getOrder() { return 0; } } // C通过注解指定 @Order(0) public class C { } A a = new A(); B b = new B(); C c = new C(); AnnotationAwareOrderComparator comparator = new AnnotationAwareOrderComparator(); List list = new ArrayList\u0026lt;\u0026gt;(); list.add(a); list.add(b); list.add(c); list.sort(comparator); System.out.println(list); A、B、C通过三种不同的方式指定了优先级顺序，执行上述代码最终得到的结果是A-\u0026gt;B-\u0026gt;C。 AnnotationAwareOrderComparator比较器的继承图中顶层是java中的Comparator接口，但是AnnotationAwareOrderComparator本身没有实现Comparator，而是在父类org.springframework.core.OrderComparator中实现了,看下OrderComparator#compare实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 org.springframework.core.OrderComparator#compare public int compare(@Nullable Object o1, @Nullable Object o2) { return doCompare(o1, o2, null); } private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) { // OrderComparator是升序排序：实现了PriorityOrdered接口最小--\u0026gt;实现了Ordered接口的第二--\u0026gt;没有实现Ordered接口最后，实现了相同接口的按getOrder()返回值进行比较 // 实现了PriorityOrdered接口 \u0026lt; 没有实现PriorityOrdered接口 boolean p1 = (o1 instanceof PriorityOrdered); boolean p2 = (o2 instanceof PriorityOrdered); if (p1 \u0026amp;\u0026amp; !p2) { return -1; } else if (p2 \u0026amp;\u0026amp; !p1) { return 1; } // 都实现了PriorityOrdered接口就使用getOrder()返回的序值进行比较 int i1 = getOrder(o1, sourceProvider); int i2 = getOrder(o2, sourceProvider); return Integer.compare(i1, i2); } doCompare方法的判断逻辑其实挺简单明了的。采用相同方式指定优先级顺序的组件那就看具体的order数值，谁小就谁优先级高；如果组件之间采用了不同的方式指定，那么使用了PriorityOrdered这种方式的实现的组件具有最高优先级。\n第11-18行：三种优先级指定方式中，实现了PriorityOrdered接口的组件拥有最高的优先级。 第21-23行：如果都实现了PriorityOrdered接口或者使用了另外两种方式指定则使用getOrder方法返回的优先级判断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 org.springframework.core.OrderComparator#getOrder(java.lang.Object) protected int getOrder(@Nullable Object obj) { if (obj != null) { Integer order = findOrder(obj); if (order != null) { return order; } } return Ordered.LOWEST_PRECEDENCE; } protected Integer findOrder(Object obj) { return (obj instanceof Ordered ? ((Ordered) obj).getOrder() : null); } 在OrderComparator#getOrder中调用了findOrder方法获取优先级顺序。findOrder方法的默认实现是当前组件实现了Ordered接口则直接获取getOrder的值，否则返回空。findOrder使用protected，具体的实现还是在子类AnnotationAwareOrderComparator中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected Integer findOrder(Object obj) { // 先获取Ordered接口中getOrder()方法返回的数值 Integer order = super.findOrder(obj); if (order != null) { return order; } // 如果没有实现Ordered接口，则获取@Order注解中指定的值 return findOrderFromAnnotation(obj); } private Integer findOrderFromAnnotation(Object obj) { AnnotatedElement element = (obj instanceof AnnotatedElement ? (AnnotatedElement) obj : obj.getClass()); MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY); Integer order = OrderUtils.getOrderFromAnnotations(element, annotations); if (order == null \u0026amp;\u0026amp; obj instanceof DecoratingProxy) { return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass()); } return order; } AnnotationAwareOrderComparator#findOrder调用父类findOrder尝试获取接口上getOrder的值，使用了PriorityOrdered、Ordered方式此处就返回了，如果使用了@Order则进一步通过findOrderFromAnnotation获取注解的优先级值。\nConditionEvaluator ConditionEvaluator作用 ConditionEvaluator条件评估器,Spring中用于根据特定条件确定是否创建bean的机制。在Spring中，通过使用条件注解和条件类，可以使用ConditionEvaluator来决定在运行时是否应该创建某个特定的bean。具体在使用的时候就是在候选的类或者方法上使用@Conditional(xxxCondition)条件注解表示bean在特定的条件下生成，涉及到的注解是org.springframework.context.annotation.Conditional,xxxCondition条件类就是实现了org.springframework.context.annotation.ConfigurationCondition的子类。看下这2个接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 org.springframework.context.annotation @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Conditional { Class\u0026lt;? extends Condition\u0026gt;[] value(); } @FunctionalInterface public interface Condition { boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } 条件注解@Conditional可作用在类或者方法上，value值是Condition类型的条件类数组，可以同时定义多个条件类。条件类需要实现Condition接口的matches方法，当条件类的matches方法返回true，ConditionEvaluator在评估这些条件注解后才会允许创建bean，反之亦然。举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Configuration public class AppConfig { @Bean @Conditional(MyCondition.class) // 使用自定义的条件类 public MyBean myBean() { return new MyBean(); } } public class MyCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 在这里编写条件的评估逻辑，返回 true 或 false // 例如，可以根据环境属性、系统属性等来确定条件是否满足 return true; // 满足条件 } } 配置类AppConfig的myBean方法会创建一个MyBean对象，但是myBean方法要生效需要条件类MyCondition的macthes方法返回true才行。那么Spring是如何实现条件机制的呢？答案就是通过ConditionEvaluator#shouldSkip方法实现的。\nConditionEvaluator#shouldSkip ConditionEvaluator调用shouldSkip方法判断bean是否需要生成，返回值true代表当前bean应该忽略跳过，false则需要创建bean。入参metadata为含有条件注解的类或方法的元数据信息，可以使用AnnotationMetadata和MethodMetadata的子类诸如SimpleAnnotationMetadata、SimpleMethodMetadata等。另一个参数phase，枚举变量，枚举值有PARSE_CONFIGURATION和REGISTER_BEAN，表示当前条件注解的条件类Condition在什么阶段生效？PARSE_CONFIGURATION为解析配置类时生效，REGISTER_BEAN为注册bean时生效，举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration public class AppConfig { @Bean @Conditional(DisableCondition.class) // 使用自定义的条件类 public MyBean myBean() { return new MyBean(); } } public class DisableCondition implements ConfigurationCondition { @Override public ConfigurationPhase getConfigurationPhase() { return ConfigurationPhase.REGISTER_BEAN; } @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 在这里编写条件的评估逻辑，返回 true 或 false // 例如，可以根据环境属性、系统属性等来确定条件是否满足 return false; // 满足条件 } } DisableCondition实现了ConfigurationCondition#getConfigurationPhase方法，matches方法返回false，shouldSkip在评估条件类DisableCondition后会返回true，表示不会向Spring中注册MyBean，但是getConfigurationPhase返回的作用阶段是REGISTER_BEAN，意味着只有在注册普通bean阶段这个条件注解才会生效。如果getConfigurationPhase方法改成返回PARSE_CONFIGURATION，即使matches方法返回的false，shouldSkip在评估条件类DisableCondition后，也不会返回true，因为此时DisableCondition的条件注解的作用阶段是PARSE_CONFIGURATION解析配置类时，而Spring在解析myBean方法时认为是REGISTER_BEAN注册bean阶段，所以Spring会认为DisableCondition无效，最终shouldSkip返回false，容器中还是会注册MyBean。ConditionEvaluator通过ConfigurationPhase对Condition的作用周期提供了更精细地控制。\n源码解析 ConditionEvaluator的评估方法有两个，如果不知道ConfigurationPhase应该传什么，可以使用第一个，知道条件注解具体的作用阶段则可以手动指定ConfigurationPhase。shouldSkip方法底层会自动判断当前条件注解的作用阶段是什么。下面具体分析下第二个shouldSkip的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 只指定元数据信息 public boolean shouldSkip(AnnotatedTypeMetadata metadata) { return shouldSkip(metadata, null); } // 使用元数据信息和具体的作用时期 public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) { if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) { return false; } if (phase == null) { if (metadata instanceof AnnotationMetadata \u0026amp;\u0026amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) { return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); } return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); } List\u0026lt;Condition\u0026gt; conditions = new ArrayList\u0026lt;\u0026gt;(); for (String[] conditionClasses : getConditionClasses(metadata)) { for (String conditionClass : conditionClasses) { Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); } } AnnotationAwareOrderComparator.sort(conditions); for (Condition condition : conditions) { ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) { requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); } if ((requiredPhase == null || requiredPhase == phase) \u0026amp;\u0026amp; !condition.matches(this.context, metadata)) { return true; } } return false; } 第8-10行：候选组件没有使用@Conditional注解的话直接返回false，候选组件则生效生成。 第12-18行：如果phase为空，智能判断当前条件注解作用时期。主要就是通过分析候选组件是否具有配置功能，如果候选组件有配置功能的话就认为当前条件注解作用时期为配置阶段PARSE_CONFIGURATION，否则就是注册普通bean阶段REGISTER_BEAN。详细逻辑下面在分析。 第20-26行：解析@Conditional注解中都有哪些条件注解Condition，用于进一步分析是否需要生成候选组件。 第28-38行：判断是否要生成候选组件。 如果条件注解没有指定具体的作用阶段，那就看matches方法返回false表示候选组件不生效，否则创建候选组件。 如果条件注解指定具体的作用阶段，只有当条件注解的实际作用阶段跟期望作用阶段一致，且matches返回false才认为候选组件不生效，其他情况候选组件都生效。 Lookup注解 在Spring框架中，@Lookup注解用于告诉Spring容器，每次调用被注解的方法时，都应该返回一个新的实例。通常情况下，Spring会在容器启动时实例化bean，并将其缓存起来供需要时使用。但是对于使用@Lookup注解标记的方法，Spring在运行时会生成一个动态的代理类来处理方法调用，并且会在每次方法调用时动态创建新的实例，而不是使用缓存的实例。\n这种动态生成新实例的方式对于一些特定的情况非常有用，比如创建原型（prototype）作用域的bean，并且希望每次注入该bean时都获取一个新的实例。通过在一个方法上添加@Lookup注解，Spring可以提供这样的功能，而无需手动编写复杂的代码来管理实例的创建和生命周期。下面举个例子说明下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public abstract class UserService{ public void test(){ System.out.println(getOrderService()); } @Lookup(\u0026#34;orderService\u0026#34;) public OrderService getOrderService(){ return null; } } @Component @Scope(\u0026#34;prototype\u0026#34;) public class OrderService { } UserService是抽象类，抽象类本身是不会被Spring实例化的。但是UserService的getOrderService方法使用了@Lookup注解，这样Spring就会实例化UserService，getOrderService方法每次被调用时都会去容器中寻找orderService的实例，由于orderService是多例，所以每次调用test方法都会返回OrderService的实例对象。\n","date":"2023-01-19T00:00:00Z","image":"https://example.com/p/spring-beandefinition%E8%A7%A3%E6%9E%90%E4%B9%8Bclasspathbeandefinitionscanner/bd_hub179f4918e5901a40076b37f231e41db_333377_120x120_fill_q75_box_smart1.jpeg","permalink":"https://example.com/p/spring-beandefinition%E8%A7%A3%E6%9E%90%E4%B9%8Bclasspathbeandefinitionscanner/","title":"Spring BeanDefinition解析之ClassPathBeanDefinitionScanner"},{"content":"主要是介绍spring源码中涉及到的一些常用知识点例如一些API的用法介绍，便于读者在阅读后续Spring主流程源码时熟悉这些API。\nBeanDefinition BeanDefinition表示Bean定义，BeanDefinition中存在很多属性用来描述一个Bean的特点。比如：\nclass，表示Bean类型 scope，表示Bean作用域，单例或原型等 lazyInit：表示Bean是否是懒加载 initMethodName：表示Bean初始化时要执行的方法 destroyMethodName：表示Bean销毁时要执行的方法 \u0026hellip; 在Spring中，我们经常会通过以下几种方式来定义Bean:\n\u0026lt;bean/\u0026gt; @Bean @Component(@Service,@Controller) 这些，我们可以称之申明式定义Bean。 还可以编程式定义Bean，那就是直接通过BeanDefinition，比如：\n1 2 3 4 5 6 7 8 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 生成一个BeanDefinition对象，并设置beanClass为User.class，并注册到ApplicationContext中 AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition(); beanDefinition.setBeanClass(User.class); context.registerBeanDefinition(\u0026#34;user\u0026#34;, beanDefinition); System.out.println(context.getBean(\u0026#34;user\u0026#34;)); 我们还可以通过BeanDefinition设置一个Bean的其他属性\n1 2 3 beanDefinition.setScope(\u0026#34;prototype\u0026#34;); // 设置作用域 beanDefinition.setInitMethodName(\u0026#34;init\u0026#34;); // 设置初始化方法 beanDefinition.setLazyInit(true); // 设置懒加载 和申明式事务、编程式事务类似，通过\u0026lt;bean/\u0026gt;，@Bean，@Component等申明式方式所定义的Bean，最终都会被Spring解析为对应的BeanDefinition对象，并放入Spring容器中。\nBeanDefinitionReader 接下来，我们来介绍几种在Spring源码中所提供的BeanDefinition读取器（BeanDefinitionReader），这些BeanDefinitionReader在我们使用Spring时用得少，但在Spring源码中用得多，相当于Spring源码的基础设施。\nAnnotatedBeanDefinitionReader 可以直接把某个类转换为BeanDefinition，并且会解析该类上的注解，比如:\n1 2 3 4 5 6 7 8 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = new AnnotatedBeanDefinitionReader(context); // 将User.class解析为BeanDefinition annotatedBeanDefinitionReader.register(User.class); System.out.println(context.getBean(\u0026#34;user\u0026#34;)); 注意：它能解析的注解是：@Conditional，@Scope、@Lazy、@Primary、@DependsOn、@Role、@Description\nXmlBeanDefinitionReader 可以解析\u0026lt;bean/\u0026gt;标签\n1 2 3 4 5 6 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(context); int i = xmlBeanDefinitionReader.loadBeanDefinitions(\u0026#34;spring.xml\u0026#34;); System.out.println(context.getBean(\u0026#34;user\u0026#34;)); ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner是扫描器，但是它的作用和BeanDefinitionReader类似，它可以进行扫描，扫描某个包路径，对扫描到的类进行解析，比如，扫描到的类上如果存在@Component注解，那么就会把这个类解析为一个BeanDefinition，比如：\n1 2 3 4 5 6 7 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.refresh(); ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context); scanner.scan(\u0026#34;com.zhouyu\u0026#34;); System.out.println(context.getBean(\u0026#34;userService\u0026#34;)); BeanFactory ApplicationContext AnnotationConfigApplicationContext ClassPathXmlApplicationContext 国际化 资源加载 获取运行时环境 事件发布 类型转化 PropertyEditor ConversionService TypeConverter OrderComparator BeanPostProcessor BeanFactoryPostProcessor FactoryBean ExcludeFilter和IncludeFilter MetadataReader、ClassMetadata、AnnotationMetadata","date":"2023-01-11T00:00:00Z","image":"https://example.com/p/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/spring-framework_huc84201bcde1c14e7efaadba74ae18986_15230_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/","title":"Spring源码解析前置知识"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://example.com/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://example.com/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://example.com/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://example.com/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://example.com/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/emoji-support/","title":"Emoji Support"}]